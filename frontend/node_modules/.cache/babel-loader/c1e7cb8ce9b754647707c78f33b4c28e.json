{"ast":null,"code":"/* eslint-disable new-cap */\n'use strict';\n\nexports.__esModule = true;\nexports.Compiler = Compiler;\nexports.precompile = precompile;\nexports.compile = compile; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _ast = require('./ast');\n\nvar _ast2 = _interopRequireDefault(_ast);\n\nvar slice = [].slice;\n\nfunction Compiler() {} // the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\n\nCompiler.prototype = {\n  compiler: Compiler,\n  equals: function equals(other) {\n    var len = this.opcodes.length;\n\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      var opcode = this.opcodes[i],\n          otherOpcode = other.opcodes[i];\n\n      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n        return false;\n      }\n    } // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n\n\n    len = this.children.length;\n\n    for (var i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  guid: 0,\n  compile: function compile(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n    options.blockParams = options.blockParams || [];\n    options.knownHelpers = _utils.extend(Object.create(null), {\n      helperMissing: true,\n      blockHelperMissing: true,\n      each: true,\n      'if': true,\n      unless: true,\n      'with': true,\n      log: true,\n      lookup: true\n    }, options.knownHelpers);\n    return this.accept(program);\n  },\n  compileProgram: function compileProgram(program) {\n    var childCompiler = new this.compiler(),\n        // eslint-disable-line new-cap\n    result = childCompiler.compile(program, this.options),\n        guid = this.guid++;\n    this.usePartial = this.usePartial || result.usePartial;\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n    return guid;\n  },\n  accept: function accept(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new _exception2['default']('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    var ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n  Program: function Program(program) {\n    this.options.blockParams.unshift(program.blockParams);\n    var body = program.body,\n        bodyLength = body.length;\n\n    for (var i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n    return this;\n  },\n  BlockStatement: function BlockStatement(block) {\n    transformLiteralToPath(block);\n    var program = block.program,\n        inverse = block.inverse;\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n    var type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block); // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse); // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n  DecoratorBlock: function DecoratorBlock(decorator) {\n    var program = decorator.program && this.compileProgram(decorator.program);\n    var params = this.setupFullMustacheParams(decorator, program, undefined),\n        path = decorator.path;\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n  PartialStatement: function PartialStatement(partial) {\n    this.usePartial = true;\n    var program = partial.program;\n\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    var params = partial.params;\n\n    if (params.length > 1) {\n      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({\n          type: 'PathExpression',\n          parts: [],\n          depth: 0\n        });\n      }\n    }\n\n    var partialName = partial.name.original,\n        isDynamic = partial.name.type === 'SubExpression';\n\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n    var indent = partial.indent || '';\n\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function PartialBlockStatement(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n  MustacheStatement: function MustacheStatement(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator: function Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n  ContentStatement: function ContentStatement(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n  CommentStatement: function CommentStatement() {},\n  SubExpression: function SubExpression(sexpr) {\n    transformLiteralToPath(sexpr);\n    var type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n    var path = sexpr.path,\n        name = path.parts[0],\n        isBlock = program != null || inverse != null;\n    this.opcode('getContext', path.depth);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n    path.strict = true;\n    this.accept(path);\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n  simpleSexpr: function simpleSexpr(sexpr) {\n    var path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n  helperSexpr: function helperSexpr(sexpr, program, inverse) {\n    var params = this.setupFullMustacheParams(sexpr, program, inverse),\n        path = sexpr.path,\n        name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n    } else {\n      path.strict = true;\n      path.falsy = true;\n      this.accept(path);\n      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));\n    }\n  },\n  PathExpression: function PathExpression(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    var name = path.parts[0],\n        scoped = _ast2['default'].helpers.scopedId(path),\n        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n    }\n  },\n  StringLiteral: function StringLiteral(string) {\n    this.opcode('pushString', string.value);\n  },\n  NumberLiteral: function NumberLiteral(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n  BooleanLiteral: function BooleanLiteral(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n  UndefinedLiteral: function UndefinedLiteral() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n  NullLiteral: function NullLiteral() {\n    this.opcode('pushLiteral', 'null');\n  },\n  Hash: function Hash(hash) {\n    var pairs = hash.pairs,\n        i = 0,\n        l = pairs.length;\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n\n    this.opcode('popHash');\n  },\n  // HELPERS\n  opcode: function opcode(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n  addDepth: function addDepth(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n  classifySexpr: function classifySexpr(sexpr) {\n    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);\n\n    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]); // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n\n    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr); // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n\n\n    var isEligible = !isBlockParam && (isHelper || isSimple); // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n\n    if (isEligible && !isHelper) {\n      var _name = sexpr.path.parts[0],\n          options = this.options;\n\n      if (options.knownHelpers[_name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n  pushParams: function pushParams(params) {\n    for (var i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n  pushParam: function pushParam(val) {\n    var value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        var blockParamIndex = undefined;\n\n        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n\n        if (blockParamIndex) {\n          var blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n\n          if (value.replace) {\n            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n\n      this.accept(val);\n    }\n  },\n  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n    var params = sexpr.params;\n    this.pushParams(params);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n  blockParamIndex: function blockParamIndex(name) {\n    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n      var blockParams = this.options.blockParams[depth],\n          param = blockParams && _utils.indexOf(blockParams, name);\n\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nfunction precompile(input, options, env) {\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n  }\n\n  options = options || {};\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nfunction compile(input, options, env) {\n  if (options === undefined) options = {};\n\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n  }\n\n  options = _utils.extend({}, options);\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var compiled = undefined;\n\n  function compileInput() {\n    var ast = env.parse(input, options),\n        environment = new env.Compiler().compile(ast, options),\n        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n    return env.template(templateSpec);\n  } // Template is only compiled on first use and cached after that point.\n\n\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled.call(this, context, execOptions);\n  }\n\n  ret._setup = function (setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled._setup(setupOptions);\n  };\n\n  ret._child = function (i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled._child(i, data, blockParams, depths);\n  };\n\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    var literal = sexpr.path; // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["slice","Compiler","prototype","compiler","equals","other","len","opcodes","length","i","opcode","otherOpcode","argEquals","args","children","guid","compile","program","options","sourceNode","stringParams","trackIds","blockParams","knownHelpers","_utils","Object","create","helperMissing","blockHelperMissing","each","unless","log","lookup","accept","compileProgram","childCompiler","result","usePartial","useDepths","node","type","unshift","ret","shift","Program","body","bodyLength","isSimple","BlockStatement","block","transformLiteralToPath","inverse","classifySexpr","helperSexpr","simpleSexpr","path","original","ambiguousSexpr","DecoratorBlock","decorator","params","setupFullMustacheParams","undefined","useDecorators","PartialStatement","partial","explicitPartialContext","push","parts","depth","partialName","name","isDynamic","indent","preventIndent","PartialBlockStatement","partialBlock","MustacheStatement","mustache","SubExpression","escaped","noEscape","Decorator","ContentStatement","content","value","CommentStatement","sexpr","isBlock","strict","knownHelpersOnly","falsy","_ast2","helpers","simpleId","PathExpression","addDepth","scoped","scopedId","blockParamId","blockParamIndex","data","StringLiteral","string","NumberLiteral","number","BooleanLiteral","bool","UndefinedLiteral","NullLiteral","Hash","hash","pairs","l","pushParam","key","call","arguments","loc","isBlockParam","isHelper","helperExpression","isEligible","_name","pushParams","val","replace","blockParamChild","join","omitEmpty","param","precompile","input","env","compat","ast","parse","environment","JavaScriptCompiler","compiled","compileInput","templateSpec","template","context","execOptions","_setup","setupOptions","_child","depths","a","b","literal"],"sources":["/Users/nandinineralagi/hw3/hw3-santorini-ndnrlg/frontend/node_modules/handlebars/lib/handlebars/compiler/compiler.js"],"sourcesContent":["/* eslint-disable new-cap */\n\nimport Exception from '../exception';\nimport { isArray, indexOf, extend } from '../utils';\nimport AST from './ast';\n\nconst slice = [].slice;\n\nexport function Compiler() {}\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n\n  equals: function(other) {\n    let len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      let opcode = this.opcodes[i],\n        otherOpcode = other.opcodes[i];\n      if (\n        opcode.opcode !== otherOpcode.opcode ||\n        !argEquals(opcode.args, otherOpcode.args)\n      ) {\n        return false;\n      }\n    }\n\n    // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n    len = this.children.length;\n    for (let i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  guid: 0,\n\n  compile: function(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n\n    options.blockParams = options.blockParams || [];\n\n    options.knownHelpers = extend(\n      Object.create(null),\n      {\n        helperMissing: true,\n        blockHelperMissing: true,\n        each: true,\n        if: true,\n        unless: true,\n        with: true,\n        log: true,\n        lookup: true\n      },\n      options.knownHelpers\n    );\n\n    return this.accept(program);\n  },\n\n  compileProgram: function(program) {\n    let childCompiler = new this.compiler(), // eslint-disable-line new-cap\n      result = childCompiler.compile(program, this.options),\n      guid = this.guid++;\n\n    this.usePartial = this.usePartial || result.usePartial;\n\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n\n    return guid;\n  },\n\n  accept: function(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new Exception('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    let ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n\n  Program: function(program) {\n    this.options.blockParams.unshift(program.blockParams);\n\n    let body = program.body,\n      bodyLength = body.length;\n    for (let i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n\n    return this;\n  },\n\n  BlockStatement: function(block) {\n    transformLiteralToPath(block);\n\n    let program = block.program,\n      inverse = block.inverse;\n\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n\n    let type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n\n  DecoratorBlock(decorator) {\n    let program = decorator.program && this.compileProgram(decorator.program);\n    let params = this.setupFullMustacheParams(decorator, program, undefined),\n      path = decorator.path;\n\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n\n  PartialStatement: function(partial) {\n    this.usePartial = true;\n\n    let program = partial.program;\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    let params = partial.params;\n    if (params.length > 1) {\n      throw new Exception(\n        'Unsupported number of partial arguments: ' + params.length,\n        partial\n      );\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({ type: 'PathExpression', parts: [], depth: 0 });\n      }\n    }\n\n    let partialName = partial.name.original,\n      isDynamic = partial.name.type === 'SubExpression';\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n\n    let indent = partial.indent || '';\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n\n  MustacheStatement: function(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n\n  ContentStatement: function(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n\n  CommentStatement: function() {},\n\n  SubExpression: function(sexpr) {\n    transformLiteralToPath(sexpr);\n    let type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function(sexpr, program, inverse) {\n    let path = sexpr.path,\n      name = path.parts[0],\n      isBlock = program != null || inverse != null;\n\n    this.opcode('getContext', path.depth);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    path.strict = true;\n    this.accept(path);\n\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n\n  simpleSexpr: function(sexpr) {\n    let path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n\n  helperSexpr: function(sexpr, program, inverse) {\n    let params = this.setupFullMustacheParams(sexpr, program, inverse),\n      path = sexpr.path,\n      name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new Exception(\n        'You specified knownHelpersOnly, but used the unknown helper ' + name,\n        sexpr\n      );\n    } else {\n      path.strict = true;\n      path.falsy = true;\n\n      this.accept(path);\n      this.opcode(\n        'invokeHelper',\n        params.length,\n        path.original,\n        AST.helpers.simpleId(path)\n      );\n    }\n  },\n\n  PathExpression: function(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    let name = path.parts[0],\n      scoped = AST.helpers.scopedId(path),\n      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode(\n        'lookupOnContext',\n        path.parts,\n        path.falsy,\n        path.strict,\n        scoped\n      );\n    }\n  },\n\n  StringLiteral: function(string) {\n    this.opcode('pushString', string.value);\n  },\n\n  NumberLiteral: function(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n\n  BooleanLiteral: function(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n\n  UndefinedLiteral: function() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n\n  NullLiteral: function() {\n    this.opcode('pushLiteral', 'null');\n  },\n\n  Hash: function(hash) {\n    let pairs = hash.pairs,\n      i = 0,\n      l = pairs.length;\n\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n    this.opcode('popHash');\n  },\n\n  // HELPERS\n  opcode: function(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n\n  addDepth: function(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n\n  classifySexpr: function(sexpr) {\n    let isSimple = AST.helpers.simpleId(sexpr.path);\n\n    let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n    // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n    let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);\n\n    // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n    let isEligible = !isBlockParam && (isHelper || isSimple);\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n    if (isEligible && !isHelper) {\n      let name = sexpr.path.parts[0],\n        options = this.options;\n      if (options.knownHelpers[name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n\n  pushParams: function(params) {\n    for (let i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n\n  pushParam: function(val) {\n    let value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        let blockParamIndex;\n        if (val.parts && !AST.helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n        if (blockParamIndex) {\n          let blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n          if (value.replace) {\n            value = value\n              .replace(/^this(?:\\.|$)/, '')\n              .replace(/^\\.\\//, '')\n              .replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n      this.accept(val);\n    }\n  },\n\n  setupFullMustacheParams: function(sexpr, program, inverse, omitEmpty) {\n    let params = sexpr.params;\n    this.pushParams(params);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n\n  blockParamIndex: function(name) {\n    for (\n      let depth = 0, len = this.options.blockParams.length;\n      depth < len;\n      depth++\n    ) {\n      let blockParams = this.options.blockParams[depth],\n        param = blockParams && indexOf(blockParams, name);\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nexport function precompile(input, options, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' +\n        input\n    );\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let ast = env.parse(input, options),\n    environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nexport function compile(input, options = {}, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.compile. You passed ' +\n        input\n    );\n  }\n\n  options = extend({}, options);\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let compiled;\n\n  function compileInput() {\n    let ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options),\n      templateSpec = new env.JavaScriptCompiler().compile(\n        environment,\n        options,\n        undefined,\n        true\n      );\n    return env.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled.call(this, context, execOptions);\n  }\n  ret._setup = function(setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._setup(setupOptions);\n  };\n  ret._child = function(i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._child(i, data, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (isArray(a) && isArray(b) && a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    let literal = sexpr.path;\n    // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}