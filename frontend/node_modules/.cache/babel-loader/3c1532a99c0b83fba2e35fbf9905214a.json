{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _base = require('../base');\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _codeGen = require('./code-gen');\n\nvar _codeGen2 = _interopRequireDefault(_codeGen);\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function nameLookup(parent, name\n  /*,  type */\n  ) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function depthedLookup(name) {\n    return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];\n  },\n  compilerInfo: function compilerInfo() {\n    var revision = _base.COMPILER_REVISION,\n        versions = _base.REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n  appendToBuffer: function appendToBuffer(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!_utils.isArray(source)) {\n      source = [source];\n    }\n\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n  initializeBuffer: function initializeBuffer() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function internalNameLookup(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n  lookupPropertyFunctionIsUsed: false,\n  compile: function compile(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n    this.preamble();\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = {\n      list: []\n    };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n    this.compileChildren(environment, options);\n    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n    var opcodes = environment.opcodes,\n        opcode = undefined,\n        firstLoc = undefined,\n        i = undefined,\n        l = undefined;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    } // Flush any trailing content that might be pending.\n\n\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n    /* istanbul ignore next */\n\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new _exception2['default']('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\\n']);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n      } else {\n        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    var fn = this.createFunctionContext(asObject);\n\n    if (!this.isChild) {\n      var ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n\n        ret.useDecorators = true;\n      }\n\n      var _context = this.context;\n      var programs = _context.programs;\n      var decorators = _context.decorators;\n\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n\n      if (this.options.data) {\n        ret.useData = true;\n      }\n\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n        this.source.currentLocation = {\n          start: {\n            line: 1,\n            column: 0\n          }\n        };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({\n            file: options.destName\n          });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n  preamble: function preamble() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new _codeGen2['default'](this.options.srcName);\n    this.decorators = new _codeGen2['default'](this.options.srcName);\n  },\n  createFunctionContext: function createFunctionContext(asObject) {\n    // istanbul ignore next\n    var _this = this;\n\n    var varDeclarations = '';\n    var locals = this.stackVars.concat(this.registers.list);\n\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    } // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n\n\n    var aliasCount = 0;\n    Object.keys(this.aliases).forEach(function (alias) {\n      var node = _this.aliases[alias];\n\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n\n    if (this.useDepths) {\n      params.push('depths');\n    } // Perform a second pass over the output to merge content when possible\n\n\n    var source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n    }\n  },\n  mergeSource: function mergeSource(varDeclarations) {\n    var isSimple = this.environment.isSimple,\n        appendOnly = !this.forceBuffer,\n        appendFirst = undefined,\n        sourceSeen = undefined,\n        bufferStart = undefined,\n        bufferEnd = undefined;\n    this.source.each(function (line) {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n    }\n\n    return this.source.merge();\n  },\n  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {\n    return '\\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\\n          return parent[propertyName];\\n        }\\n        return undefined\\n    }\\n    '.trim();\n  },\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function blockValue(name) {\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n    var blockName = this.popStack();\n    params.splice(1, 0, blockName);\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function ambiguousBlockValue() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n    this.flushInline();\n    var current = this.topStack();\n    params.splice(1, 0, current);\n    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n  },\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function appendContent(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function append() {\n    if (this.isInline()) {\n      this.replaceStack(function (current) {\n        return [' != null ? ', current, ' : \"\"'];\n      });\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      var local = this.popStack();\n      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n\n      if (this.environment.isSimple) {\n        this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n      }\n    }\n  },\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function appendEscaped() {\n    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n  },\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function getContext(depth) {\n    this.lastContext = depth;\n  },\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function pushContext() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n    var i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n    this.useBlockParams = true;\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function lookupData(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n  resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n    // istanbul ignore next\n    var _this2 = this;\n\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    var len = parts.length;\n\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(function (current) {\n        var lookup = _this2.nameLookup(current, parts[i], type); // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n\n\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function resolvePossibleLambda() {\n    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n  },\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function pushStringParam(string, type) {\n    this.pushContext();\n    this.pushString(type); // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n  emptyHash: function emptyHash(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n\n      this.push('{}'); // hashTypes\n    }\n\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function pushHash() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n\n    this.hash = {\n      values: {},\n      types: [],\n      contexts: [],\n      ids: []\n    };\n  },\n  popHash: function popHash() {\n    var hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function pushString(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function pushLiteral(value) {\n    this.pushStackLiteral(value);\n  },\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function pushProgram(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator: function registerDecorator(paramSize, name) {\n    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n        options = this.setupHelperArgs(name, paramSize);\n    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n  },\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n    var nonHelper = this.popStack(),\n        helper = this.setupHelper(paramSize, name);\n    var possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    } // call a function from the input object\n\n\n    possibleFunctionCalls.push(nonHelper);\n\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));\n    }\n\n    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];\n    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);\n    this.push(functionCall);\n  },\n  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {\n    var result = [];\n    result.push(items[0]);\n\n    for (var i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n    this.useRegister('helper');\n    var nonHelper = this.popStack();\n    this.emptyHash();\n    var helper = this.setupHelper(0, name, helperCall);\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));\n    }\n\n    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n  },\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function invokePartial(isDynamic, name, indent) {\n    var params = [],\n        options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n\n    options = this.objectLiteral(options);\n    params.push(options);\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function assignToHash(key) {\n    var value = this.popStack(),\n        context = undefined,\n        type = undefined,\n        id = undefined;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    var hash = this.hash;\n\n    if (context) {\n      hash.contexts[key] = context;\n    }\n\n    if (type) {\n      hash.types[key] = type;\n    }\n\n    if (id) {\n      hash.ids[key] = id;\n    }\n\n    hash.values[key] = value;\n  },\n  pushId: function pushId(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n  // HELPERS\n  compiler: JavaScriptCompiler,\n  compileChildren: function compileChildren(environment, options) {\n    var children = environment.children,\n        child = undefined,\n        compiler = undefined;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      var existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function matchExistingProgram(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n  programExpression: function programExpression(guid) {\n    var child = this.environment.children[guid],\n        programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n  useRegister: function useRegister(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n  push: function push(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n  pushStackLiteral: function pushStackLiteral(item) {\n    this.push(new Literal(item));\n  },\n  pushSource: function pushSource(source) {\n    if (this.pendingContent) {\n      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n  replaceStack: function replaceStack(callback) {\n    var prefix = ['('],\n        stack = undefined,\n        createdStack = undefined,\n        usedLiteral = undefined;\n    /* istanbul ignore next */\n\n    if (!this.isInline()) {\n      throw new _exception2['default']('replaceStack on non-inline');\n    } // We want to merge the inline statement into the replacement statement via ','\n\n\n    var top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n\n      var _name = this.incrStack();\n\n      prefix = ['((', this.push(_name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    var item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n\n    if (createdStack) {\n      this.stackSlot--;\n    }\n\n    this.push(prefix.concat(item, ')'));\n  },\n  incrStack: function incrStack() {\n    this.stackSlot++;\n\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n\n    return this.topStackName();\n  },\n  topStackName: function topStackName() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function flushInline() {\n    var inlineStack = this.inlineStack;\n    this.inlineStack = [];\n\n    for (var i = 0, len = inlineStack.length; i < len; i++) {\n      var entry = inlineStack[i];\n      /* istanbul ignore if */\n\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        var stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function isInline() {\n    return this.inlineStack.length;\n  },\n  popStack: function popStack(wrapped) {\n    var inline = this.isInline(),\n        item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new _exception2['default']('Invalid stack pop');\n        }\n\n        this.stackSlot--;\n      }\n\n      return item;\n    }\n  },\n  topStack: function topStack() {\n    var stack = this.isInline() ? this.inlineStack : this.compileStack,\n        item = stack[stack.length - 1];\n    /* istanbul ignore if */\n\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n  contextName: function contextName(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n  quotedString: function quotedString(str) {\n    return this.source.quotedString(str);\n  },\n  objectLiteral: function objectLiteral(obj) {\n    return this.source.objectLiteral(obj);\n  },\n  aliasable: function aliasable(name) {\n    var ret = this.aliases[name];\n\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n    return ret;\n  },\n  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n    var params = [],\n        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    var foundHelper = this.nameLookup('helpers', name, 'helper'),\n        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n  setupParams: function setupParams(helper, paramSize, params) {\n    var options = {},\n        contexts = [],\n        types = [],\n        ids = [],\n        objectArgs = !params,\n        param = undefined;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    var inverse = this.popStack(),\n        program = this.popStack(); // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    } // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n\n\n    var i = paramSize;\n\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n\n    return options;\n  },\n  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n    var options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function () {\n  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\n  for (var i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n/**\n * @deprecated May be removed in the next major version\n */\n\n\nJavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  var stack = compiler.popStack(),\n      i = 0,\n      len = parts.length;\n\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];\n  } else {\n    return stack;\n  }\n}\n\nexports['default'] = JavaScriptCompiler;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["Literal","value","JavaScriptCompiler","prototype","nameLookup","parent","name","internalNameLookup","depthedLookup","aliasable","JSON","stringify","compilerInfo","revision","versions","_base","appendToBuffer","source","location","explicit","_utils","wrap","environment","isSimple","initializeBuffer","quotedString","lookupPropertyFunctionIsUsed","compile","options","context","asObject","stringParams","trackIds","precompile","isChild","decorators","programs","environments","preamble","stackSlot","stackVars","aliases","registers","list","hashes","compileStack","inlineStack","blockParams","compileChildren","useDepths","useDecorators","compat","useBlockParams","opcodes","opcode","firstLoc","i","l","length","currentLocation","loc","apply","args","pushSource","isEmpty","prepend","lookupPropertyFunctionVarDeclaration","push","Function","merge","undefined","fn","createFunctionContext","ret","compiler","main","main_d","usePartial","data","useData","start","line","column","objectLiteral","srcName","toStringWithSourceMap","file","destName","map","toString","compilerOptions","lastContext","varDeclarations","locals","concat","join","aliasCount","Object","keys","forEach","node","_this","alias","children","referenceCount","params","mergeSource","appendOnly","forceBuffer","appendFirst","sourceSeen","bufferStart","bufferEnd","each","add","substring","trim","blockValue","blockHelperMissing","contextName","setupHelperArgs","blockName","popStack","splice","functionCall","ambiguousBlockValue","flushInline","current","topStack","lastHelper","appendContent","content","pendingContent","pendingLocation","append","isInline","replaceStack","local","appendEscaped","getContext","depth","pushContext","pushStackLiteral","lookupOnContext","parts","falsy","strict","scoped","resolvePath","lookupBlockParam","blockParamId","lookupData","type","assumeObjects","strictLookup","len","lookup","_this2","resolvePossibleLambda","pushStringParam","string","pushString","emptyHash","omitEmpty","pushHash","hash","values","types","contexts","ids","popHash","pop","pushLiteral","pushProgram","guid","programExpression","registerDecorator","paramSize","foundDecorator","invokeHelper","nonHelper","helper","setupHelper","possibleFunctionCalls","functionLookupCode","itemsSeparatedBy","callParams","items","separator","result","invokeKnownHelper","invokeAmbiguous","helperCall","useRegister","helperName","paramsInit","invokePartial","isDynamic","indent","setupParams","helpers","partials","unshift","depths","assignToHash","key","id","pushId","child","existing","matchExistingProgram","index","equals","programParams","expr","item","callback","prefix","stack","createdStack","usedLiteral","top","_name","incrStack","call","topStackName","entry","wrapped","inline","str","obj","blockHelper","foundHelper","callContext","objectArgs","param","hashIds","hashTypes","hashContexts","inverse","program","generateArray","reservedWords","split","compilerWords","RESERVED_WORDS","isValidJavaScriptVariableName","test","requireTerminal"],"sources":["/Users/nandinineralagi/hw3/hw3-santorini-ndnrlg/frontend/node_modules/handlebars/lib/handlebars/compiler/javascript-compiler.js"],"sourcesContent":["import { COMPILER_REVISION, REVISION_CHANGES } from '../base';\nimport Exception from '../exception';\nimport { isArray } from '../utils';\nimport CodeGen from './code-gen';\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function(name) {\n    return [\n      this.aliasable('container.lookup'),\n      '(depths, ',\n      JSON.stringify(name),\n      ')'\n    ];\n  },\n\n  compilerInfo: function() {\n    const revision = COMPILER_REVISION,\n      versions = REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n\n  appendToBuffer: function(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n\n  initializeBuffer: function() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n\n  lookupPropertyFunctionIsUsed: false,\n\n  compile: function(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = { list: [] };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n\n    this.compileChildren(environment, options);\n\n    this.useDepths =\n      this.useDepths ||\n      environment.useDepths ||\n      environment.useDecorators ||\n      this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n    let opcodes = environment.opcodes,\n      opcode,\n      firstLoc,\n      i,\n      l;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new Exception('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n\n      this.decorators.prepend([\n        'var decorators = container.decorators, ',\n        this.lookupPropertyFunctionVarDeclaration(),\n        ';\\n'\n      ]);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, [\n          'fn',\n          'props',\n          'container',\n          'depth0',\n          'data',\n          'blockParams',\n          'depths',\n          this.decorators.merge()\n        ]);\n      } else {\n        this.decorators.prepend(\n          'function(fn, props, container, depth0, data, blockParams, depths) {\\n'\n        );\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    let fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      let ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n\n      let { programs, decorators } = this.context;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n\n        this.source.currentLocation = { start: { line: 1, column: 0 } };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({ file: options.destName });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n\n  preamble: function() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new CodeGen(this.options.srcName);\n    this.decorators = new CodeGen(this.options.srcName);\n  },\n\n  createFunctionContext: function(asObject) {\n    let varDeclarations = '';\n\n    let locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    let aliasCount = 0;\n    Object.keys(this.aliases).forEach(alias => {\n      let node = this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    let params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    let source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap([\n        'function(',\n        params.join(','),\n        ') {\\n  ',\n        source,\n        '}'\n      ]);\n    }\n  },\n  mergeSource: function(varDeclarations) {\n    let isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst,\n      sourceSeen,\n      bufferStart,\n      bufferEnd;\n    this.source.each(line => {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations +=\n        ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend(\n        'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n')\n      );\n    }\n\n    return this.source.merge();\n  },\n\n  lookupPropertyFunctionVarDeclaration: function() {\n    return `\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    `.trim();\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function(name) {\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n\n    let blockName = this.popStack();\n    params.splice(1, 0, blockName);\n\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n\n    this.flushInline();\n\n    let current = this.topStack();\n    params.splice(1, 0, current);\n\n    this.pushSource([\n      'if (!',\n      this.lastHelper,\n      ') { ',\n      current,\n      ' = ',\n      this.source.functionCall(blockHelperMissing, 'call', params),\n      '}'\n    ]);\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function() {\n    if (this.isInline()) {\n      this.replaceStack(current => [' != null ? ', current, ' : \"\"']);\n\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      let local = this.popStack();\n      this.pushSource([\n        'if (',\n        local,\n        ' != null) { ',\n        this.appendToBuffer(local, undefined, true),\n        ' }'\n      ]);\n      if (this.environment.isSimple) {\n        this.pushSource([\n          'else { ',\n          this.appendToBuffer(\"''\", undefined, true),\n          ' }'\n        ]);\n      }\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function() {\n    this.pushSource(\n      this.appendToBuffer([\n        this.aliasable('container.escapeExpression'),\n        '(',\n        this.popStack(),\n        ')'\n      ])\n    );\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function(depth) {\n    this.lastContext = depth;\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function(parts, falsy, strict, scoped) {\n    let i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function(blockParamId, parts) {\n    this.useBlockParams = true;\n\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n\n  resolvePath: function(type, parts, i, falsy, strict) {\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    let len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(current => {\n        let lookup = this.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function() {\n    this.push([\n      this.aliasable('container.lambda'),\n      '(',\n      this.popStack(),\n      ', ',\n      this.contextName(0),\n      ')'\n    ]);\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n\n  emptyHash: function(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = { values: {}, types: [], contexts: [], ids: [] };\n  },\n  popHash: function() {\n    let hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator(paramSize, name) {\n    let foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n\n    this.decorators.push([\n      'fn = ',\n      this.decorators.functionCall(foundDecorator, '', [\n        'fn',\n        'props',\n        'container',\n        options\n      ]),\n      ' || fn;'\n    ]);\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function(paramSize, name, isSimple) {\n    let nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n\n    let possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    let functionLookupCode = [\n      '(',\n      this.itemsSeparatedBy(possibleFunctionCalls, '||'),\n      ')'\n    ];\n    let functionCall = this.source.functionCall(\n      functionLookupCode,\n      'call',\n      helper.callParams\n    );\n    this.push(functionCall);\n  },\n\n  itemsSeparatedBy: function(items, separator) {\n    let result = [];\n    result.push(items[0]);\n    for (let i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function(paramSize, name) {\n    let helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function(name, helperCall) {\n    this.useRegister('helper');\n\n    let nonHelper = this.popStack();\n\n    this.emptyHash();\n    let helper = this.setupHelper(0, name, helperCall);\n\n    let helperName = (this.lastHelper = this.nameLookup(\n      'helpers',\n      name,\n      'helper'\n    ));\n\n    let lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(\n        ' != null ? helper : ',\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    this.push([\n      '(',\n      lookup,\n      helper.paramsInit ? ['),(', helper.paramsInit] : [],\n      '),',\n      '(typeof helper === ',\n      this.aliasable('\"function\"'),\n      ' ? ',\n      this.source.functionCall('helper', 'call', helper.callParams),\n      ' : helper))'\n    ]);\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function(isDynamic, name, indent) {\n    let params = [],\n      options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function(key) {\n    let value = this.popStack(),\n      context,\n      type,\n      id;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    let hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n\n  pushId: function(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral(\n        'blockParams[' +\n          name[0] +\n          '].path[' +\n          name[1] +\n          ']' +\n          (child ? ' + ' + JSON.stringify('.' + child) : '')\n      );\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function(environment, options) {\n    let children = environment.children,\n      child,\n      compiler;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      let existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        let index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(\n          child,\n          options,\n          this.context,\n          !this.precompile\n        );\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function(child) {\n    for (let i = 0, len = this.context.environments.length; i < len; i++) {\n      let environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n\n  programExpression: function(guid) {\n    let child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n\n  useRegister: function(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  push: function(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  pushStackLiteral: function(item) {\n    this.push(new Literal(item));\n  },\n\n  pushSource: function(source) {\n    if (this.pendingContent) {\n      this.source.push(\n        this.appendToBuffer(\n          this.source.quotedString(this.pendingContent),\n          this.pendingLocation\n        )\n      );\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n\n  replaceStack: function(callback) {\n    let prefix = ['('],\n      stack,\n      createdStack,\n      usedLiteral;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new Exception('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    let top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      let name = this.incrStack();\n\n      prefix = ['((', this.push(name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    let item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n\n  incrStack: function() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function() {\n    let inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (let i = 0, len = inlineStack.length; i < len; i++) {\n      let entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        let stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function(wrapped) {\n    let inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new Exception('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function() {\n    let stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  contextName: function(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n\n  quotedString: function(str) {\n    return this.source.quotedString(str);\n  },\n\n  objectLiteral: function(obj) {\n    return this.source.objectLiteral(obj);\n  },\n\n  aliasable: function(name) {\n    let ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n\n    return ret;\n  },\n\n  setupHelper: function(paramSize, name, blockHelper) {\n    let params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    let foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(\n        `${this.contextName(0)} != null ? ${this.contextName(\n          0\n        )} : (container.nullContext || {})`\n      );\n\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n\n  setupParams: function(helper, paramSize, params) {\n    let options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    let inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    let i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n\n  setupHelperArgs: function(helper, paramSize, params, useRegister) {\n    let options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function() {\n  const reservedWords = (\n    'break else new var' +\n    ' case finally return void' +\n    ' catch for switch while' +\n    ' continue function this with' +\n    ' default if throw' +\n    ' delete in try' +\n    ' do instanceof typeof' +\n    ' abstract enum int short' +\n    ' boolean export interface static' +\n    ' byte extends long super' +\n    ' char final native synchronized' +\n    ' class float package throws' +\n    ' const goto private transient' +\n    ' debugger implements protected volatile' +\n    ' double import public let yield await' +\n    ' null true false'\n  ).split(' ');\n\n  const compilerWords = (JavaScriptCompiler.RESERVED_WORDS = {});\n\n  for (let i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n  return (\n    !JavaScriptCompiler.RESERVED_WORDS[name] &&\n    /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)\n  );\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  let stack = compiler.popStack(),\n    i = 0,\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [\n      compiler.aliasable('container.strict'),\n      '(',\n      stack,\n      ', ',\n      compiler.quotedString(parts[i]),\n      ', ',\n      JSON.stringify(compiler.source.currentLocation),\n      ' )'\n    ];\n  } else {\n    return stack;\n  }\n}\n\nexport default JavaScriptCompiler;\n"]},"metadata":{},"sourceType":"script"}