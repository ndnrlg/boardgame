{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.SourceLocation = SourceLocation;\nexports.id = id;\nexports.stripFlags = stripFlags;\nexports.stripComment = stripComment;\nexports.preparePath = preparePath;\nexports.prepareMustache = prepareMustache;\nexports.prepareRawBlock = prepareRawBlock;\nexports.prepareBlock = prepareBlock;\nexports.prepareProgram = prepareProgram;\nexports.preparePartialBlock = preparePartialBlock; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    var errorNode = {\n      loc: open.path.loc\n    };\n    throw new _exception2['default'](open.path.original + \" doesn't match \" + close, errorNode);\n  }\n}\n\nfunction SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nfunction id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nfunction stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nfunction stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nfunction preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n  var original = data ? '@' : '',\n      dig = [],\n      depth = 0;\n\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var part = parts[i].part,\n        // If we have [] syntax then we do not treat path references as operators,\n    // i.e. foo.[this] resolves to approximately context.foo['this']\n    isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new _exception2['default']('Invalid path: ' + original, {\n          loc: loc\n        });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data: data,\n    depth: depth,\n    parts: dig,\n    original: original,\n    loc: loc\n  };\n}\n\nfunction prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  var escapeFlag = open.charAt(3) || open.charAt(2),\n      escaped = escapeFlag !== '{' && escapeFlag !== '&';\n  var decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path: path,\n    params: params,\n    hash: hash,\n    escaped: escaped,\n    strip: strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n  locInfo = this.locInfo(locInfo);\n  var program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program: program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nfunction prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  var decorator = /\\*/.test(openBlock.open);\n  program.blockParams = openBlock.blockParams;\n  var inverse = undefined,\n      inverseStrip = undefined;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program: program,\n    inverse: inverse,\n    openStrip: openBlock.strip,\n    inverseStrip: inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    var firstLoc = statements[0].loc,\n        lastLoc = statements[statements.length - 1].loc;\n    /* istanbul ignore else */\n\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nfunction preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program: program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}","map":{"version":3,"mappings":"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","names":["validateClose","open","close","path","original","errorNode","loc","SourceLocation","source","locInfo","start","line","first_line","column","first_column","end","last_line","last_column","id","token","test","substring","length","stripFlags","charAt","stripComment","comment","replace","preparePath","data","parts","dig","depth","i","l","part","isLiteral","separator","push","type","prepareMustache","params","hash","strip","escapeFlag","escaped","decorator","prepareRawBlock","openRawBlock","contents","program","body","openStrip","inverseStrip","closeStrip","prepareBlock","openBlock","inverseAndProgram","inverted","blockParams","inverse","chain","prepareProgram","statements","firstLoc","lastLoc","preparePartialBlock","name"],"sources":["/Users/nandinineralagi/hw3/hw3-santorini-ndnrlg/frontend/node_modules/handlebars/lib/handlebars/compiler/helpers.js"],"sourcesContent":["import Exception from '../exception';\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    let errorNode = { loc: open.path.loc };\n\n    throw new Exception(\n      open.path.original + \" doesn't match \" + close,\n      errorNode\n    );\n  }\n}\n\nexport function SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nexport function id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nexport function stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nexport function stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nexport function preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n\n  let original = data ? '@' : '',\n    dig = [],\n    depth = 0;\n\n  for (let i = 0, l = parts.length; i < l; i++) {\n    let part = parts[i].part,\n      // If we have [] syntax then we do not treat path references as operators,\n      // i.e. foo.[this] resolves to approximately context.foo['this']\n      isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new Exception('Invalid path: ' + original, { loc });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data,\n    depth,\n    parts: dig,\n    original,\n    loc\n  };\n}\n\nexport function prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  let escapeFlag = open.charAt(3) || open.charAt(2),\n    escaped = escapeFlag !== '{' && escapeFlag !== '&';\n\n  let decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path,\n    params,\n    hash,\n    escaped,\n    strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n\n  locInfo = this.locInfo(locInfo);\n  let program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nexport function prepareBlock(\n  openBlock,\n  program,\n  inverseAndProgram,\n  close,\n  inverted,\n  locInfo\n) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  let decorator = /\\*/.test(openBlock.open);\n\n  program.blockParams = openBlock.blockParams;\n\n  let inverse, inverseStrip;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new Exception(\n        'Unexpected inverse block on decorator',\n        inverseAndProgram\n      );\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program,\n    inverse,\n    openStrip: openBlock.strip,\n    inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    const firstLoc = statements[0].loc,\n      lastLoc = statements[statements.length - 1].loc;\n\n    /* istanbul ignore else */\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nexport function preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n"]},"metadata":{},"sourceType":"script"}